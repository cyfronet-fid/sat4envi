import { Overlay } from './../../state/overlay/overlay.model';
import { AbstractControl } from '@angular/forms';
import { over } from 'cypress/types/lodash';

/* BASE URL */
const HTTP_PREFIX = '(http(s?):\\/\\/)?';
const LOCALHOST = '(localhost)';
const DOMAIN_NAME = '((www\\.)?(([a-zA-Z0-9\\-\\_]*\\.)+)([a-zA-Z0-9\\-\\_]{2,3}))';
const LOCAL_SUB_PAGES = '((\\/[a-zA-Z0-9]*)+)';
const IP = '(\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b)';
const BASE_URL = HTTP_PREFIX + '(' + LOCALHOST + '|' + DOMAIN_NAME + '|' + IP + '|' + LOCAL_SUB_PAGES + ')';

/* ADVANCED URL PARTS (OPTIONAL) */
const PORT = '(:[0-9]{1,5})?';
const SUB_PAGES = '((\\/[a-zA-Z0-9\\.]*)+)?';
const PARAMETERS = '((\\?)([a-zA-Z0-9\\-\\_\\.]*=[a-zA-Z\\-\\_\\.0-9]*(&?))+)?';

/* FULL URL ASSEMBLY */
const URL_EXPRESSION = new RegExp(BASE_URL + PORT + SUB_PAGES + PARAMETERS, 'i');

const VERSION_EXPRESSION = /version=\d+\.\d+\.\d+(&?)/i;
const REQUEST_EXPRESSION = /request=[a-zA-Z]*(&?)/i;
const LAYERS_EXPRESSION = /layers=[a-zA-Z._0-9,:]*(&?)/i;
const STYLES_EXPRESSION = /styles=[a-zA-Z._0-9,:]*(&?)/i;
const BBOX_EXPRESSION = /bbox=[.0-9]*,[.0-9]*,[.0-9]*,[.0-9]*(&?)/i;
const SRS_OR_CRS_EXPRESSION = /(srs|crs)=[a-zA-Z._0-9]*:[a-zA-Z._0-9]*(&?)/i;
const WIDTH_EXPRESSION = /width=\d(&?)/i;
const HEIGHT_EXPRESSION = /height=\d(&?)/i;
const FORMAT_EXPRESSION = /format=image\/(vnd.jpeg-png|vnd.jpeg-png8|png|gif|tiff|jpg)(&?)/i;
const WMS_SERVICE_EXPRESSION = /service=wms(&?)/i;
const TRANSPARENT_EXPRESSION = /transparent=(false|true)(&?)/i;

/**
 * List of params to be removed from url
 * due to autogenerated duplicates by openlayers lib
*/
const PARAMS_TO_BE_REMOVED = [
  VERSION_EXPRESSION,
  REQUEST_EXPRESSION,
  WMS_SERVICE_EXPRESSION,
  TRANSPARENT_EXPRESSION,
  BBOX_EXPRESSION,
  SRS_OR_CRS_EXPRESSION,
  WIDTH_EXPRESSION,
  HEIGHT_EXPRESSION,
  FORMAT_EXPRESSION
];

/**
 * Params to be extracted due to correct usage
 * of openlayers image wms
 */
const PARAMS_TO_BE_EXTRACTED = [
  LAYERS_EXPRESSION,
  STYLES_EXPRESSION
];

/**
 * List of params documented in source
 * https://mapserver.org/ogc/wms_server.html#test-with-a-getmap-request
 */
const RECOGNIZED_PARAMS_EXPRESSIONS = [
  ...PARAMS_TO_BE_REMOVED,
  ...PARAMS_TO_BE_EXTRACTED
];


export const WMS_URL_VALIDATORS = [
  urlValidator,

  /* OPTIONAL */
  wmsServiceValidator,
  requestValidator,
  layersValidator,
  stylesValidator,
  transparentValidator,
  versionValidator,
  srsOrCrsValidator,
  bboxValidator,
  widthValidator,
  heightValidator,
  formatValidator
];

export function getNotRecognizedParamsBy(url: string): string | null {
  const restOfParams = _getRestOfParams(url, RECOGNIZED_PARAMS_EXPRESSIONS);
  if (!restOfParams) {
    return null;
  }

  const paramsNames = restOfParams.split('&')
    .map(paramWithValue => paramWithValue.split('=')[0]);
  return paramsNames
    .filter(paramName => !!paramName && paramName !== '' && isNaN(paramName as any))
    .join(', ');
}

export function removeAutoGeneratedParams(url: string): string | null {
  if (typeof url !== "string") {
    return null;
  }

  let preparedUrl = url;
  PARAMS_TO_BE_REMOVED
    .forEach(regex => preparedUrl = preparedUrl.replace(regex, ''));

  return preparedUrl;
}

export function getBaseUrlAndParamsFrom(overlay: Overlay): {url: string, [param: string]: any} {
  const url = overlay.url;
  if (!_hasMatch(url, URL_EXPRESSION)) {
    return {url: overlay.url};
  }

  const urlBaseAndParams = url.split('?');
  if (urlBaseAndParams.length === 1) {
    return {url: urlBaseAndParams[0]};
  }

  const urlBase = urlBaseAndParams[0];
  const urlParams = urlBaseAndParams[1];

  return {url: urlBase, ..._extractParamsMapFrom(urlParams)};
}


interface IValidatorOutput {
  [key: string]: boolean;
}


function urlValidator(control: AbstractControl): IValidatorOutput | null {
  return _hasMatch(control.value, URL_EXPRESSION) ? null : { url: true };
}

/* OPTIONAL */
const VERSION_PARAM = 'version=';
function versionValidator(control: AbstractControl): IValidatorOutput | null {
  return _hasOptionalParam(control.value, VERSION_EXPRESSION, VERSION_PARAM, { version: true });
}

/* OPTIONAL */
const SRS_PARAM = 'srs=';
const CRS_PARAM = 'crs=';
function srsOrCrsValidator(control: AbstractControl): IValidatorOutput | null {
  return _hasOptionalParam(control.value, SRS_OR_CRS_EXPRESSION, CRS_PARAM, { srsOrCrs: true })
    || _hasOptionalParam(control.value, SRS_OR_CRS_EXPRESSION, SRS_PARAM, { srsOrCrs: true });
}

/* OPTIONAL */
const BBOX_PARAM = 'bbox=';
function bboxValidator(control: AbstractControl): IValidatorOutput | null {
  return _hasOptionalParam(control.value, BBOX_EXPRESSION, BBOX_PARAM, { bbox: true });
}

/* OPTIONAL */
const WIDTH_PARAM = 'width=';
function widthValidator(control: AbstractControl): IValidatorOutput | null {
  return _hasOptionalParam(control.value, WIDTH_EXPRESSION, WIDTH_PARAM, { width: true });
}

/* OPTIONAL */
const HEIGHT_PARAM = 'height=';
function heightValidator(control: AbstractControl): IValidatorOutput | null {
  return _hasOptionalParam(control.value, HEIGHT_EXPRESSION, HEIGHT_PARAM, { height: true });
}

/* OPTIONAL */
const FORMAT_PARAM = 'format=';
function formatValidator(control: AbstractControl): IValidatorOutput | null {
  return _hasOptionalParam(control.value, FORMAT_EXPRESSION, FORMAT_PARAM, { format: true });
}

/* OPTIONAL */
const SERVICE_PARAM = 'service=';
function wmsServiceValidator(control: AbstractControl): IValidatorOutput | null {
  return _hasOptionalParam(control.value, WMS_SERVICE_EXPRESSION, SERVICE_PARAM, { wmsService: true });
}

/* OPTIONAL */
const REQUEST_PARAM = 'request=';
function requestValidator(control: AbstractControl): IValidatorOutput | null {
  return _hasOptionalParam(control.value, REQUEST_EXPRESSION, REQUEST_PARAM, { request: true });
}

/* OPTIONAL */
const TRANSPARENT_PARAM = 'transparent=';
function transparentValidator(control: AbstractControl): IValidatorOutput | null {
  return _hasOptionalParam(control.value, TRANSPARENT_EXPRESSION, TRANSPARENT_PARAM, { transparent: true });
}

/* OPTIONAL */
const LAYERS_PARAM = 'layers=';
function layersValidator(control: AbstractControl): IValidatorOutput | null {
  return _hasOptionalParam(control.value, LAYERS_EXPRESSION, LAYERS_PARAM, { layers: true });
}

/* OPTIONAL */
const STYLES_PARAM = 'styles=';
function stylesValidator(control: AbstractControl): IValidatorOutput | null {
  return _hasOptionalParam(control.value, STYLES_EXPRESSION, STYLES_PARAM, { styles: true });
}


function _extractParamsMapFrom(partialUrl: string) {
  const extractedParams: {[param: string]: any} = {};
  PARAMS_TO_BE_EXTRACTED
    .map(regex => partialUrl.match(regex))
    .filter(match => !!match && match.length > 0)
    .map(match => match[0].replace('&', '').split('='))
    .forEach(([key, value]) => extractedParams[key] = value);

  return extractedParams;
}

function _getRestOfParams(url: string, regexes: RegExp[]) {
  if (typeof url !== "string") {
    return null;
  }

  const urlParams = url.split('?');
  const hasParams = urlParams.length === 2;
  if (!hasParams) {
    return null;
  }

  let paramsAsString = urlParams[1];
  RECOGNIZED_PARAMS_EXPRESSIONS
    .map(regex => paramsAsString = paramsAsString.replace(regex, ''));

  return paramsAsString;
}

function _hasOptionalParam(
  url: string,
  paramRegex: RegExp,
  paramName: string,
  output: IValidatorOutput
): IValidatorOutput | null {
  const hasOptionalParam = _hasMatch(url, URL_EXPRESSION)
    && (
      !_exist(url, paramName)
      || _hasMatch(url, paramRegex)
    );
  return hasOptionalParam ? null : output;
}

function _hasMatch(url: string, regex: RegExp) {
  return (typeof url === "string") && regex.test(url);
}

function _exist(url: string, paramName: string) {
  return (typeof url === "string")
    && url.toLowerCase().indexOf(paramName.toLowerCase()) > -1;
}
